#!/usr/bin/env python3

"""
Installation script generator.

Generates shell scripts for installing software packages on different Linux distributions, by
receiving a declarative YAML configuration file as input.
"""

from dataclasses import dataclass, field, replace
from abc import ABC, abstractmethod

import argparse
import sys
from typing import ClassVar, Generic, TypeVar
import yaml


def main(args: argparse.Namespace) -> None:
    """
    Usage: installscript.py <config.yaml> --os <os_name> [--out <output.sh>]
    """
    platform = PLATFORMS.get(args.os)
    if platform is None:
        print(f"Error: Unsupported OS '{args.os}'. Supported OS: {', '.join(PLATFORMS.keys())}")
        sys.exit(1)

    try:
        with open(args.config_path, 'r') as file:
            config = yaml.safe_load(file)
    except FileNotFoundError:
        print(f"Error: Config file not found: {args.config_path}")
        sys.exit(1)
    except yaml.YAMLError as e:
        print(f"Error: Invalid YAML in config file: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: Failed to read config file: {e}")
        sys.exit(1)

    packages = load_packages(config, platform)
    resolved = resolve_packages(packages)
    merged = merge_packages([
        pkg.calculate_transitive_dependencies(resolved)
        for pkg in resolved
    ])

    lines = [
        "#!/usr/bin/env bash",
        "",
        "# -----------------------------------------------------------------------------",
        "# This script was automatically generated by installscript.",
        "#",
        "# This file is produced from a YAML configuration and is intended to automate",
        "# the installation of software packages and dependencies for Linux systems.",
        "#",
        "# Any manual changes to this file will be lost if it is regenerated.",
        "# To modify the installation process, edit the YAML config and regenerate.",
        "#",
        "# For more information, visit: https://github.com/RaniAgus/installscript",
        "# -----------------------------------------------------------------------------",
        "",
        "set -e",
        "",
        *(pkg.print() for pkg in merged)
    ]

    script_content = "\n".join(lines).strip()

    if args.out:
        with open(args.out, 'w') as outfile:
            outfile.write(script_content)
    else:
        print(script_content)


def load_packages(config: dict, platform: Platform) -> dict[str, list[Package]]:
    return {
        name: pkgs
        for name, pkg_list in config.items()
        for pkgs in [load_package_list(name, pkg_list, platform)]
        if len(pkgs) > 0
    }


def load_package_list(name: str, config: list[dict], platform: Platform) -> list[Package]:
    for item in config:
        packages = Package.create(
            name,
            item if isinstance(item, dict) else {"type": item},
            platform,
        )

        if len(packages) > 0:
            return packages

    return []


def resolve_packages(packages: dict[str, list[Package]]) -> list[Package]:
    seen: set[Package] = set()
    return [
        resolved
        for pkg_list in packages.values()
        for pkg in pkg_list
        for resolved in pkg.resolve(packages)
        if resolved not in seen and seen.add(resolved) is None # type: ignore[func-returns-value]
    ]


def merge_packages(packages: list[Package]) -> list[Package]:
    merged: list[Package] = []

    for pkg in packages:
        for i, existing in enumerate(merged):
            merged_pkg = existing.merge(pkg)
            if merged_pkg is not None:
                merged[i] = merged_pkg
                break
        else:
            merged.append(pkg)

    return merged


## Platforms ###

@dataclass(frozen=True)
class Platform(ABC):
    preinstalled_packages: tuple[str, ...] = field(default_factory=tuple)
    blacklisted_types: tuple[str, ...] = field(default_factory=tuple)

    def allows(self, package_type: str) -> bool:
        return package_type not in self.blacklisted_types

    def preinstalls(self, package_type: str) -> bool:
        return package_type in self.preinstalled_packages


PLATFORMS = {
    'ubuntu': Platform(
        preinstalled_packages=('bash', 'apt', 'deb', 'snapd'),
        blacklisted_types=('dnf',),
    ),
    'popos': Platform(
        preinstalled_packages=('bash', 'apt', 'deb', 'flatpak'),
        blacklisted_types=('dnf',),
    ),
    'mint': Platform(
        preinstalled_packages=('bash', 'apt', 'deb'),
        blacklisted_types=('dnf',),
    ),
    'fedora': Platform(
        preinstalled_packages=('bash', 'dnf', 'flatpak'),
        blacklisted_types=('apt', 'deb'),
    ),
}


### Package Implementations ###

T = TypeVar('T', bound='Package')

@dataclass(frozen=True)
class Package(ABC, Generic[T]):
    factories: ClassVar[dict[str, type[Package]]] = {}

    satisfies: tuple[str, ...] = field(default_factory=tuple)
    pre_install: tuple[Command, ...] = field(default_factory=tuple)
    post_install: tuple[Command, ...] = field(default_factory=tuple)
    flags: tuple[str, ...] = field(default_factory=tuple)
    dependencies: tuple[str, ...] = field(default_factory=tuple)

    def __init_subclass__(cls, *, type: str | None = None, **kwargs):
        super().__init_subclass__(**kwargs)
        if type is not None:
            cls.factories[type] = cls

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        if 'type' not in item:
            return []

        if not platform.allows(item['type']):
            return []

        factory = cls.factories.get(item['type'], UndefinedPackage)
        return factory.create(name, item, platform)


    def print(self) -> str:
        parts = []

        for cmd in self.pre_install:
            parts.append(cmd.print())

        parts.append("".join(self.print_package()).strip())

        for cmd in self.post_install:
            parts.append(cmd.print())

        return "\n\n".join(parts) + "\n"

    @abstractmethod
    def print_package(self) -> list[str]:
        pass

    def resolve(self, all_packages: dict[str, list[Package]]) -> list[Package]:
        return [self]

    def merge(self: T, other: Package) -> T | None:
        if not isinstance(other, type(self)):
            return None

        if self.flags != other.flags:
            return None

        if not set(self.dependencies).isdisjoint(set(other.satisfies)):
            return None

        if not set(other.dependencies).isdisjoint(set(self.satisfies)):
            return None

        return self.apply_merge(other)

    def apply_merge(self: T, other: T) -> T | None:
        return None

    def calculate_transitive_dependencies(self, packages: list[Package]) -> Package:
        return replace(self, dependencies=tuple(sorted(self.all_dependencies(packages))))

    def all_dependencies(self, packages: list[Package]) -> set[str]:
        dependencies = set(self.dependencies)
        dependencies.update(
            transitive_dep
            for dep in self.dependencies
            for pkg in packages
            if dep in pkg.satisfies
            for transitive_dep in pkg.all_dependencies(packages)
        )
        return dependencies


@dataclass(frozen=True)
class DnfPackage(Package, type='dnf'):
    packages: tuple[str, ...] = field(default_factory=tuple)
    sudo: bool = field(default=True)

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        packages = create_packages_list(item, name)
        pre_install, post_install, deps = create_common_package_fields(name, item, platform)
        flags = item.get('flags', [])
        sudo = item.get('sudo', True)

        if not platform.preinstalls('dnf'):
            deps['dnf'] = [UndefinedPackage(name='dnf')]

        if 'repofile' in item:
            repo_file = item['repofile']
            pre_install.append(ShellCommand(
                command=f"sudo dnf config-manager addrepo --from-repofile={repo_file} --overwrite\n"
            ))

        if 'repo' in item:
            flags.append(f"--repo {item['repo']}")

        if 'copr' in item:
            pre_install.append(ShellCommand(
                command=f"sudo dnf copr enable {item['copr']} -y\n"
            ))

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            DnfPackage(
                satisfies=(name,),
                packages=tuple(packages),
                sudo=sudo,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                flags=tuple(flags),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        parts = []
        if self.sudo:
            parts.append('sudo ')
        parts.append('dnf install -y ')

        for pkg in self.packages:
            parts.append('"')
            parts.append(pkg)
            parts.append('" ')

        for flag in self.flags:
            parts.append(flag)
            parts.append(" ")

        return parts

    def apply_merge(self, other: 'DnfPackage') -> 'DnfPackage' | None:
        merged_packages = tuple(sorted(set(self.packages) | set(other.packages)))
        return DnfPackage(
            satisfies=self.satisfies + other.satisfies,
            packages=merged_packages,
            sudo=self.sudo,
            pre_install=self.pre_install + other.pre_install,
            post_install=self.post_install + other.post_install,
            flags=self.flags,
            dependencies=self.dependencies + other.dependencies,
        )


@dataclass(frozen=True)
class AptPackage(Package, type='apt'):
    packages: tuple[str, ...] = field(default_factory=tuple)
    sudo: bool = field(default=True)

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        packages = create_packages_list(item, name)
        pre_install, post_install, deps = create_common_package_fields(name, item, platform)
        flags = item.get('flags', [])
        sudo = item.get('sudo', True)

        if not platform.preinstalls('apt'):
            deps['apt'] = [UndefinedPackage(name='apt')]

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            AptPackage(
                satisfies=(name,),
                packages=tuple(packages),
                sudo=sudo,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                flags=tuple(flags),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        parts = []
        if self.sudo:
            parts.append('sudo ')
        parts.append('apt-get install -y ')

        for pkg in self.packages:
            parts.append('"')
            parts.append(pkg)
            parts.append('" ')

        for flag in self.flags:
            parts.append(flag)
            parts.append(' ')

        return parts

    def apply_merge(self, other: 'AptPackage') -> 'AptPackage' | None:
        merged_packages = tuple(sorted(set(self.packages) | set(other.packages)))
        return AptPackage(
            satisfies=self.satisfies + other.satisfies,
            packages=merged_packages,
            sudo=self.sudo,
            pre_install=self.pre_install + other.pre_install,
            post_install=self.post_install + other.post_install,
            flags=self.flags,
            dependencies=self.dependencies + other.dependencies,
        )


@dataclass(frozen=True)
class DebPackage(Package, type='deb'):
    packages: tuple[str, ...] = field(default_factory=tuple)
    sudo: bool = field(default=True)

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        packages = create_packages_list(item, name)
        pre_install, post_install, deps = create_common_package_fields(name, item, platform)
        flags = item.get('flags', [])
        sudo = item.get('sudo', True)

        if not platform.preinstalls('deb'):
            deps['deb'] = [UndefinedPackage(name='deb')]

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            DebPackage(
                satisfies=(name,),
                packages=tuple(packages),
                sudo=sudo,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                flags=tuple(flags),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        parts = []

        for pkg in self.packages:
            parts.append('TMP_FILE=$(mktemp)\n')
            parts.append('wget -O "$TMP_FILE" "')
            parts.append(pkg)
            parts.append('"\n')
            if self.sudo:
                parts.append('sudo ')
            parts.append('apt-get install -y "$TMP_FILE" ')

            for flag in self.flags:
                parts.append(flag)
                parts.append(" ")

            parts.append("\n")
            parts.append('rm "$TMP_FILE"\n')

        return parts


@dataclass(frozen=True)
class SnapPackage(Package, type='snapd'):
    packages: tuple[str, ...] = field(default_factory=tuple)
    sudo: bool = field(default=True)

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        packages = create_packages_list(item, name)
        pre_install, post_install, deps = create_common_package_fields(name, item, platform)
        flags = item.get('flags', [])
        sudo = item.get('sudo', True)

        if not platform.preinstalls('snapd'):
            deps['snapd'] = [UndefinedPackage(name='snapd')]

        if 'classic' in item and item['classic']:
            flags.append('--classic')

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            SnapPackage(
                satisfies=(name,),
                packages=tuple(packages),
                sudo=sudo,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                flags=tuple(flags),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        parts = []
        if self.sudo:
            parts.append('sudo ')
        parts.append('snap install ')

        for pkg in self.packages:
            parts.append('"')
            parts.append(pkg)
            parts.append('" ')

        for flag in self.flags:
            parts.append(flag)
            parts.append(' ')

        return parts

    def apply_merge(self, other: 'SnapPackage') -> 'SnapPackage' | None:
        if self.sudo != other.sudo:
            return None

        merged_packages = tuple(sorted(set(self.packages) | set(other.packages)))
        return SnapPackage(
            satisfies=self.satisfies + other.satisfies,
            packages=merged_packages,
            sudo=self.sudo,
            pre_install=self.pre_install + other.pre_install,
            post_install=self.post_install + other.post_install,
            flags=self.flags,
            dependencies=self.dependencies + other.dependencies,
        )


@dataclass(frozen=True)
class FlatpakPackage(Package, type='flatpak'):
    remote: str = field(default="flathub")
    packages: tuple[str, ...] = field(default_factory=tuple)
    sudo: bool = field(default=False)

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        packages = create_packages_list(item, name)
        pre_install, post_install, deps = create_common_package_fields(name, item, platform)
        flags = item.get('flags', [])
        sudo = item.get('sudo', False)

        if not platform.preinstalls('flatpak'):
            deps['flatpak'] = [UndefinedPackage(name='flatpak')]

        remote = "flathub"
        if 'remote' in item:
            remote = item['remote']

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            FlatpakPackage(
                satisfies=(name,),
                packages=tuple(packages),
                sudo=sudo,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                flags=tuple(flags),
                dependencies=tuple(deps.keys()),
                remote=remote,
            )
        ]

    def print_package(self) -> list[str]:
        parts = []
        if self.sudo:
            parts.append('sudo ')
        parts.append('flatpak install -y ')
        parts.append(self.remote)
        parts.append(' ')

        for pkg in self.packages:
            parts.append('"')
            parts.append(pkg)
            parts.append('" ')

        for flag in self.flags:
            parts.append(flag)
            parts.append(" ")

        return parts

    def apply_merge(self, other: 'FlatpakPackage') -> 'FlatpakPackage' | None:
        if self.sudo != other.sudo:
            return None

        merged_packages = tuple(sorted(set(self.packages) | set(other.packages)))
        return FlatpakPackage(
            satisfies=self.satisfies + other.satisfies,
            packages=merged_packages,
            sudo=self.sudo,
            pre_install=self.pre_install + other.pre_install,
            post_install=self.post_install + other.post_install,
            flags=self.flags,
            dependencies=self.dependencies + other.dependencies,
            remote=self.remote,
        )


@dataclass(frozen=True)
class PipPackage(Package, type='pip'):
    packages: tuple[str, ...] = field(default_factory=tuple)
    sudo: bool = field(default=False)

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        packages = create_packages_list(item, name)
        pre_install, post_install, deps = create_common_package_fields(name, item, platform)
        flags = item.get('flags', [])
        sudo = item.get('sudo', False)

        if not platform.preinstalls('pip'):
            deps['pip'] = [UndefinedPackage(name='pip')]

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            PipPackage(
                satisfies=(name,),
                packages=tuple(packages),
                sudo=sudo,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                flags=tuple(flags),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        parts = []
        if self.sudo:
            parts.append('sudo ')
        parts.append("pip install -U ")
        for pkg in self.packages:
            parts.append('"')
            parts.append(pkg)
            parts.append('" ')

        for flag in self.flags:
            parts.append(flag)
            parts.append(' ')

        return parts

    def apply_merge(self, other: 'PipPackage') -> 'PipPackage' | None:
        if self.sudo != other.sudo:
            return None

        merged_packages = tuple(sorted(set(self.packages) | set(other.packages)))
        return PipPackage(
            satisfies=self.satisfies + other.satisfies,
            packages=merged_packages,
            sudo=self.sudo,
            pre_install=self.pre_install + other.pre_install,
            post_install=self.post_install + other.post_install,
            flags=self.flags,
            dependencies=self.dependencies + other.dependencies,
        )


@dataclass(frozen=True)
class TarPackage(Package, type='tar'):
    url: str = field(default="")
    sudo: bool = field(default=False)
    destination: str = field(default="")

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        url = item.get('url')
        destination = item.get('destination')
        sudo = item.get('sudo', False)

        if not url:
            raise ValueError(f"TarPackage '{name}': 'url' field is required")
        if not destination:
            raise ValueError(f"TarPackage '{name}': 'destination' field is required")

        pre_install, post_install, deps = create_common_package_fields(name, item, platform)

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            TarPackage(
                satisfies=(name,),
                url=url,
                destination=destination,
                sudo=sudo,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        parts = []
        parts.append('curl -fsSL "')
        parts.append(self.url)
        parts.append('" | ')

        if self.sudo:
            parts.append('sudo ')

        parts.append('tar xzvC "')
        parts.append(self.destination)
        parts.append('"')

        return parts


@dataclass(frozen=True)
class ZipPackage(Package, type='zip'):
    url: str = field(default="")
    sudo: bool = field(default=False)
    destination: str = field(default="")

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        url = item.get('url')
        destination = item.get('destination')
        sudo = item.get('sudo', False)

        if not url:
            raise ValueError(f"ZipPackage '{name}': 'url' field is required")
        if not destination:
            raise ValueError(f"ZipPackage '{name}': 'destination' field is required")

        pre_install, post_install, deps = create_common_package_fields(name, item, platform)

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            ZipPackage(
                satisfies=(name,),
                url=url,
                destination=destination,
                sudo=sudo,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        lines = []
        lines.append('TMP_FILE=$(mktemp)\n')
        lines.append('curl -fsSL "')
        lines.append(self.url)
        lines.append('" -o "$TMP_FILE"\n')
        if self.sudo:
            lines.append('sudo ')
        lines.append('unzip "$TMP_FILE" -d "')
        lines.append(self.destination)
        lines.append('"\n')
        lines.append('rm "$TMP_FILE"\n')

        return lines


@dataclass(frozen=True)
class GitHubPackage(Package, type='github'):
    repository: str = field(default="")
    install: str = field(default="")

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        repository = item.get('repository')
        install = item.get('install', "")

        if not repository:
            raise ValueError(f"GitHubPackage '{name}': 'repository' field is required")
        if not install:
            raise ValueError(f"GitHubPackage '{name}': 'install' field is required")

        pre_install, post_install, deps = create_common_package_fields(name, item, platform)

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            GitHubPackage(
                satisfies=(name,),
                repository=repository,
                install=install,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        lines = []
        lines.append('TMP_DIR=$(mktemp -d)\n')
        lines.append('git clone https://github.com/')
        lines.append(self.repository)
        lines.append('.git "$TMP_DIR"\n')
        lines.append('(\n')
        lines.append('  cd "$TMP_DIR"\n')

        for line in self.install.splitlines():
            lines.append('  ')
            lines.append(line)
            lines.append('\n')

        lines.append(')\n')
        lines.append('rm -rf "$TMP_DIR"\n')

        return lines


@dataclass(frozen=True)
class FilePackage(Package, type='file'):
    url: str = field(default="")
    destination: str = field(default="")
    sudo: bool = field(default=False)
    silent: bool = field(default=False)
    executable: bool = field(default=False)

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        url = item.get('url')
        destination = item.get('destination')
        sudo = item.get('sudo', False)
        silent = item.get('silent', False)
        executable = item.get('executable', False)

        if not url or not destination:
            raise RuntimeError(f"FilePackage requires 'url' and 'destination' fields.")

        pre_install, post_install, deps = create_common_package_fields(name, item, platform)

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            FilePackage(
                satisfies=(name,),
                url=url,
                destination=destination,
                sudo=sudo,
                silent=silent,
                executable=executable,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        parts = []
        parts.append('curl -fsSL "')
        parts.append(self.url)
        parts.append('" | ')

        if self.sudo:
            parts.append("sudo ")

        parts.append('tee "')
        parts.append(self.destination)
        parts.append('"')

        if self.silent:
            parts.append(' > /dev/null')

        if self.executable:
            parts.append('\n')

            if self.sudo:
                parts.append('sudo ')

            parts.append('chmod +x "')
            parts.append(self.destination)
            parts.append('"')

        return parts


@dataclass(frozen=True)
class AppImagePackage(Package, type='appimage'):
    url: str = field(default="")
    name: str = field(default="")
    icon_name: str = field(default="")

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        url = item.get('url')
        icon_name = item.get('icon_name')

        if not url:
            raise RuntimeError(f"AppImagePackage requires 'url' field.")
        if not icon_name:
            raise RuntimeError(f"AppImagePackage requires 'icon_name' field.")

        # Add dependency on appimage setup
        pre_install, post_install, deps = create_common_package_fields(name, item, platform)

        if not platform.preinstalls('appimage'):
            deps['appimage'] = [UndefinedPackage(name='appimage')]

        # Set up post_install commands for desktop integration
        app_name = item.get('name', name)
        destination = f"$HOME/.local/bin/{app_name}.AppImage"

        # Desktop file creation
        desktop_entry = []
        desktop_entry.append('[Desktop Entry]')
        desktop_entry.append(f'Name={app_name}')
        desktop_entry.append('StartupNotify=true')
        desktop_entry.append('Type=Application')
        desktop_entry.append('Terminal=false')
        desktop_entry.append(f'Categories={";".join(item.get('categories', 'Application'))};')
        desktop_entry.append(f'Icon={icon_name}')
        desktop_entry.append(f'Exec={destination}')
        desktop_entry.append('')

        post_install.append(
            TeeCommand(
                '\n'.join(desktop_entry),
                destination=f"$HOME/.local/share/applications/{app_name}.desktop",
                mkdir=True,
            )
        )

        # Icon extraction if icon_name is provided
        if icon_name:
            post_install_command = []
            post_install_command.append('(')
            post_install_command.append('  TMP_DIR=$(mktemp -d)')
            post_install_command.append('  cd "$TMP_DIR" || exit')
            post_install_command.append(f'  "{destination}" --appimage-extract')
            post_install_command.append('  cp -rv squashfs-root/usr/share/icons/hicolor/* "$HOME/.local/share/icons/hicolor/" 2>/dev/null || true')
            post_install_command.append('  rm -rf "$TMP_DIR"')
            post_install_command.append(')')

            post_install.append(
                ShellCommand(command='\n'.join(post_install_command))
            )


        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            AppImagePackage(
                satisfies=(name,),
                url=url,
                name=app_name,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        parts = []
        destination = f"$HOME/.local/bin/{self.name}.AppImage"

        # Download AppImage
        parts.append('curl -fsSL "')
        parts.append(self.url)
        parts.append('" -o "')
        parts.append(destination)
        parts.append('" > /dev/null\n')

        # Make executable
        parts.append('chmod +x "')
        parts.append(destination)
        parts.append('"\n')

        return parts


@dataclass(frozen=True)
class ShellPackage(Package, type='shell'):
    shell: str = field(default="bash")
    script: str | None = field(default=None)
    url: str | None = field(default=None)
    sudo: bool = field(default=False)

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        shell = item.get('shell', 'bash')
        script = item.get('script')
        url = item.get('url')
        sudo = item.get('sudo', False)

        if not script and not url:
            raise RuntimeError(f"ShellPackage requires either 'script' or 'url' field.")

        pre_install, post_install, deps = create_common_package_fields(name, item, platform)

        if not platform.preinstalls(shell):
            deps[shell] = [UndefinedPackage(name=shell)]

        return [
            *(pkg for pkgs in deps.values() for pkg in pkgs),
            ShellPackage(
                satisfies=(name,),
                shell=shell,
                script=script,
                url=url,
                sudo=sudo,
                pre_install=tuple(pre_install),
                post_install=tuple(post_install),
                dependencies=tuple(deps.keys()),
            )
        ]

    def print_package(self) -> list[str]:
        parts = []

        if self.url:
            parts.append(self.shell)
            parts.append(' -c "$(curl -fsSL "')
            parts.append(self.url)
            parts.append('")"')
        elif self.script:
            parts.append(self.shell)
            parts.append(' -i -c "\n')
            parts.append(script_escape(self.script))
            parts.append('" </dev/null')
        else:
            raise RuntimeError("ShellPackage requires either 'script' or 'url' field.")

        return parts


@dataclass(frozen=True)
class UndefinedPackage(Package):
    name: str = field(default="undefined")

    @classmethod
    def create(cls, name: str, item: dict, platform: Platform) -> list[Package]:
        return [UndefinedPackage(name=name)]

    def print_package(self) -> list[str]:
        return [f"# TODO: Add installation command for package: {self.name}"]

    def resolve(self, all_packages: dict[str, list[Package]]) -> list[Package]:
        return [
            resolved
            for pkg in all_packages.get(self.name, [])
            if pkg != self
            for resolved in pkg.resolve(all_packages)
        ] if self.name in all_packages else super().resolve(all_packages)


## Package Helpers ###


def create_packages_list(item: dict, default: str) -> list[str]:
    if 'packages' in item:
        return item['packages']
    else:
        return [default]


def create_common_package_fields(name: str, item: dict, platform: Platform) -> tuple[list[Command], list[Command], dict[str, list[Package]]]:
    pre_install = create_install_commands(item.get('pre_install', []))
    post_install = create_install_commands(item.get('post_install', []))
    deps = load_dependencies(name, item.get('depends_on', []), platform)
    return pre_install, post_install, deps


def create_install_commands(commands: list | dict | str) -> list[Command]:
    return [
        cmd
        for command in (commands if isinstance(commands, list) else [commands])
        for cmd in [Command.create(
            command if isinstance(command, dict)
            else {'type': 'shell', 'command': command}
        )]
        if cmd is not None
    ]


def load_dependencies(name: str, config: list[dict], platform: Platform) -> dict[str, list[Package]]:
    deps: dict[str, list[Package]] = {}

    for i, item in enumerate(config):
        if isinstance(item, str):
            deps[item] = [UndefinedPackage(name=item)]
            continue

        deps[f"__{name}_{i}"] = Package.create(f"__{name}_{i}", item, platform)

    return deps


def script_escape(script: str) -> str:
    return script.replace('\\', '\\\\').replace('"', '\\"').replace('$', '\\$').replace('`', '\\`')


## Command Implementations ###

@dataclass(frozen=True)
class Command:
    factories: ClassVar[dict[str, type[Command]]] = {}

    def __init_subclass__(cls, *, type: str | None = None, **kwargs):
        super().__init_subclass__(**kwargs)
        if type is not None:
            cls.factories[type] = cls

    @classmethod
    def create(cls, item: dict) -> Command | None:
        factory = cls.factories.get(item.get('type', ''))
        return factory.create(item) if factory else None

    @abstractmethod
    def print(self) -> str:
        pass


@dataclass(frozen=True)
class ShellCommand(Command, type='shell'):
    command: str = field(default="")

    @classmethod
    def create(cls, item: dict) -> Command:
        return ShellCommand(command=item['command'])

    def print(self) -> str:
        return self.command.strip()


@dataclass(frozen=True)
class TeeCommand(Command, type='tee'):
    content: str = field(default="")
    destination: str = field(default="")
    sudo: bool = field(default=False)
    append: bool = field(default=False)
    mkdir: bool = field(default=False)

    @classmethod
    def create(cls, item: dict) -> Command:
        return TeeCommand(
            content=item['content'],
            destination=item['destination'],
            sudo=item.get('sudo', False),
            append=item.get('append', False),
            mkdir=item.get('mkdir', False)
        )

    def print(self) -> str:
        parts = []

        if self.mkdir:
            parts.append('mkdir -p "$(dirname "')
            parts.append(self.destination)
            parts.append(')"\n')

        if self.sudo:
            parts.append('sudo ')

        parts.append('tee ')

        if self.append:
            parts.append('-a ')

        parts.append('"')
        parts.append(self.destination)
        parts.append('"')
        parts.append(" <<'EOF'\n")
        parts.append(self.content)
        parts.append("EOF")

        return "".join(parts).strip()


## Entry Point ###


if __name__ == "__main__":
    args_parser = argparse.ArgumentParser(description="Generate installation scripts from YAML config.")
    args_parser.add_argument("config_path", help="Path to the YAML configuration file.")
    args_parser.add_argument("--os", required=True, help="Target operating system (e.g., 'ubuntu', 'fedora').")
    args_parser.add_argument("--out", help="Output shell script file path (optional, defaults to stdout).")
    args = args_parser.parse_args(sys.argv[1:])
    main(args)
